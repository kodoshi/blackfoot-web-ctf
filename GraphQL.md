# GraphQL challenges

## Confessions [https://confessions.secu-web.blackfoot.dev/]

### Description

During this challenge, we had to recover a message written earlier by another user.

With each new char that is entered in the `Message` field, an `addConfession` request (which adds a confession) and `confession` (which gets a confession with a hash) are performed.

Through previous knowledge of GraphQL inner workings, burp suite enumeration and simply reading official docs, we have more information about the specific routes. Another example is to use the `__schema` route which gives us the schema of the GraphQL API.

### Solution

We found a `requestsLog` route, which makes it possible to recover all the logs made of previous requests & messages.:
```
{
   "name": "requestsLog",
   "args": [],
   "timestamp": "Wed, 03 Mar 2023 15:00:00 GMT",
   }
},
```
We can see the different hashes generated by the `confession` route, and the message that was sent with the `addConfession` route, along with timestamps.
Since a hash is generated with each new letter, the sha256 can be re-built.

Naturally, this can be automated with a python script:

```
import string
from hashlib import sha256

confession_hashes = [
"SOME",
"HASHES",
"HERE",
]
curr_hash = ""
encrypted_hash = ""
starter_msg = "Z"
valid = False

for hash in confession_hashes:
    valid = False
    for el in string.printable:
        curr_hash = starter_msg + el
        encrypted_hash = sha256(curr_hash.encode('utf-8')).hexdigest()
        if encrypted_hash == hash:
            valid = True
            break
    if valid :
        starter_msg = curr_hash
    else:
        print("Error")

print(starter_msg)
```
This Python script attempts to crack a series of SHA256 hashes stored in the confession_hashes list by brute force.

For each hash in the confession_hashes list, it enters a nested loop that iterates over all printable ASCII characters. For each character, the script appends it to starter_msg to form curr_hash, calculates its SHA256 hash using the sha256() function, and stores the result in encrypted_hash.

If encrypted_hash matches the current hash being tested, the script updates starter_msg to be the current curr_hash.

Once all hashes have been tested, the script prints the the rebuilt flag itself.

#### Screenshots

#### Resources